import java_cup.runtime.*;
import core.modeling.metamodel.*;
import core.modeling.parser.*;
import core.modeling.*;
import core.nodos.*;

action code {:
  private AcoesSemanticas instance = AcoesSemanticas.getInstance();
  private Constraint constraintAtual;
:}

parser code {: 
  public void report_error(String message, Object info) {
    String mensagem = "Erro Sintatico ";
    if (info instanceof Symbol) {
    	Symbol token = (Symbol) info;
      	mensagem += "na linha " + (token.left+1) + " e coluna " + (token.right+1) + " ";
    }
    mensagem += ": " + message;
    System.out.println(mensagem);
  }
  
  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Finalizando o compilador (erro fatal de sintaxe)!");
  }
:};

// Terminais
terminal PARENTESQ, PARENTDIR;
terminal PONTO, DOISPONTOS, DOISPONTOSDUPLO;
terminal VIRGULA, RESULT;
terminal SELF, ACESSOCOLECOES;
terminal PRE, POST, CONTEXT, APRE;
terminal MAIOR, MAIORIGUAL, MENOR, MENORIGUAL, IGUAL, DIFERENTE;
terminal AND, OR, NOT, XOR, IMPLIES;
terminal IF, THEN, ELSE, ENDIF;
terminal MAIS, MENOS, VEZES, DIVISAO;
terminal String COLECAO;
terminal String STRING;
terminal Integer INTEGER;
terminal Boolean BOOL;
terminal Double REAL;
terminal Object ID;

// Nao-terminais
non terminal oclExpressions, constraint, constraintRecursao, constraintAux;
non terminal contextDeclaration, contextDefinition, operationContext, timeExpression;
non terminal stereotype, formalParameterList, formalParameterListAux;

non terminal Object collectionType;
non terminal Object returnType;
non terminal Object pathName;
non terminal Object typeSpecifier;
non terminal Object simpleTypeSpecifier;
non terminal Object operationName;
non terminal Object unaryOperator;
non terminal Object addOperator;
non terminal Object multiplyOperator;
non terminal Object logicalOperator;
non terminal Object relationalOperator;
non terminal NoParametros actualParameterList;
non terminal NoParametros actualParameterListAux;
non terminal NoParametros propertyCallParameters;
non terminal NoExpressao oclExpression;
non terminal NoExpressao propertyCallCollection;
non terminal NoExpressao logicalExpression;
non terminal NoExpressao propertyCall;
non terminal NoExpressao logicalExpAux;
non terminal NoExpressao relationalExpression;
non terminal NoExpressao multiplicativeExpression;
non terminal NoExpressao multiplicativeExpAux;
non terminal NoExpressao additiveExpression;
non terminal NoExpressao additiveExpAux;
non terminal NoExpressao unaryExpression;
non terminal NoExpressao primaryExpression;
non terminal NoExpressao postfixExpression;
non terminal NoExpressao postfixExpAux;
non terminal NoExpressao ifExpression;
non terminal NoExpressao postfixSelfExpression;
non terminal NoExpressao postfixSelfExpAux;
non terminal NoExpressao postfixResultExpression;
non terminal NoExpressao postfixResultExpAux;
non terminal NoExpressao literal;
non terminal NoExpressao number;
non terminal NoExpressao expression;

// Precedencia
precedence left VIRGULA;
precedence left IMPLIES;
precedence left NOT;
precedence left AND;
precedence left OR;
precedence left XOR;
precedence left IGUAL, DIFERENTE;
precedence left MENOR, MAIOR, MAIORIGUAL, MENORIGUAL;
precedence left IF, THEN, ELSE, ENDIF;
precedence left MAIS, MENOS;
precedence left VEZES, DIVISAO;
precedence left NOT;
precedence left PONTO, ACESSOCOLECOES;
precedence left APRE;

// Regras
start with oclExpressions;

oclExpressions ::= constraint oclExpressions |;

constraintRecursao ::= constraintAux |;

oclExpression ::= expression:no    
			   {:
					instance.verificaTipoDoNo(noleft, noright, no, TipoPrimitivoEnum.BOOLEAN);
					RESULT = instance.criaNo(TipoPrimitivoEnum.BOOLEAN, no.getValor());
			   :}
				| postfixResultExpression:noE relationalOperator:op {: instance.voltaContexto(); :} relationalExpression:noD
			   {:
					instance.verificaConformidade(noEleft, noEright, noE, noD);
					RESULT = instance.criaNoDeResultRelacional(TipoPrimitivoEnum.BOOLEAN, noE, op, noD);
			   :};

expression ::= logicalExpression:no
				{:
					RESULT = no;
				:};

logicalExpression ::= relationalExpression:noE logicalExpAux:noD
				{:
					instance.verificaConformidade(noEleft, noEright, noE, noD);
					RESULT = instance.criaNo(noE.getTipo(), noE, noD);
				:};

logicalExpAux ::= logicalOperator:op relationalExpression:noE logicalExpAux:noD
				{: 
					instance.verificaConformidade(noEleft, noEright, noE, noD);
					RESULT = instance.criaNo(noE.getTipo(), op, noE, noD);
				:} |;
													
relationalExpression ::= additiveExpression:noE relationalOperator:op additiveExpression:noD
				{:
					instance.verificaConformidade(noEleft, noEright, noE, noD);
					instance.verificaValidadeOperador(noEleft, noEright, noE.getTipo().getNome(), op);
					RESULT = instance.criaNo(TipoPrimitivoEnum.BOOLEAN, noE, op, noD);
				:}
					| additiveExpression:no
				{:
					RESULT = no;
				:};
                          
additiveExpression ::= multiplicativeExpression:noE additiveExpAux:noD
				{:
					instance.verificaOperadorNumerico(noEleft, noDright, noE, noD);
					instance.verificaConformidade(noEleft, noEright, noE, noD);
					RESULT = instance.criaNo(instance.maiorTipo(noE, noD), noE, noD);
				:};

additiveExpAux ::= addOperator:op multiplicativeExpression:noE additiveExpAux:noD
				{:
					instance.verificaOperadorNumerico(noEleft, noDright, noE, noD);
					instance.verificaConformidade(noEleft, noEright, noE, noD);
					RESULT = instance.criaNo(instance.maiorTipo(noE, noD), op, noE, noD);
				:} |;

multiplicativeExpression ::= unaryExpression:noE multiplicativeExpAux:noD
				{:
					instance.verificaOperadorNumerico(noEleft, noDright, noE, noD);
					instance.verificaConformidade(noEleft, noEright, noE, noD);
					RESULT = instance.criaNo(instance.maiorTipo(noE, noD), noE, noD);
				:};

multiplicativeExpAux ::= multiplyOperator:op unaryExpression:noE multiplicativeExpAux:noD 
				{:
					instance.verificaOperadorNumerico(noEleft, noDright, noE, noD);
					instance.verificaConformidade(noEleft, noEright, noE, noD);
					RESULT = instance.criaNo(instance.maiorTipo(noE, noD), op, noE, noD);
				:} |; 

unaryExpression ::= unaryOperator:op postfixExpression:no
				{: 
					instance.verificaExpressaoUnaria(opleft, opright, op, no);
					instance.verificaOpEspecial(no);
					RESULT = instance.criaNo(no.getTipo(), no, op);
				:}
					| postfixExpression:no 
				{:
					instance.verificaOpEspecial(no);
					RESULT = no;
				:};

ifExpression ::= IF expression:noCond THEN expression:noE ELSE expression:noD ENDIF 
				{:
					instance.verificaTipoDoNo(noCondleft, noCondright, noCond, TipoPrimitivoEnum.BOOLEAN);
					instance.verificaConformidade(noEleft, noEright, noE, noD);
					RESULT = instance.criaNoIfExpression(noCond, noE, noD);
                :};

postfixExpression ::= primaryExpression:noE postfixExpAux:aux
				{:
					RESULT = instance.criaNoNavegacao(noE, aux);
					instance.finalizaNavegacao(); // navegacao terminou
				:}
					| postfixSelfExpression:noE postfixSelfExpAux:aux
				{:
					RESULT = instance.criaNoNavegacao(noE, aux);
					instance.finalizaNavegacao(); // navegacao terminou
				:}
					| postfixResultExpression:noE postfixResultExpAux:aux
				{:
					RESULT = instance.criaNoNavegacao(noE, aux);
					instance.finalizaNavegacao(); // navegacao terminou
				:};
                      
postfixExpAux ::=  PONTO propertyCall:pc {: instance.trocaContexto(pc); :} postfixExpAux:rec 
				{:
				    RESULT = instance.criaNoNavegacao(pc, rec);
				:}
				    | ACESSOCOLECOES:ac {: instance.verificaSeContextoEhColecao(acleft, acright); :}
				    				propertyCallCollection:pc {: instance.trocaContexto(pc); :} postfixExpAux:rec
				{:
				    RESULT = instance.criaNoNavegacao(pc, rec);
				:} | ;

postfixSelfExpression ::= SELF
				{:
					RESULT = instance.criaNoSelf();
					instance.trocaContexto(RESULT);
				:}
                    | SELF timeExpression
				{:
					RESULT = instance.criaNoSelf();
					instance.trocaContexto(RESULT);
				:};
									
postfixSelfExpAux ::= PONTO propertyCall:pc {: instance.trocaContexto(pc); :} postfixExpAux:rec 
				{:
					RESULT = instance.criaNoNavegacao(pc, rec);
				:} |;
									
postfixResultExpression ::= RESULT:valor
				{:
					instance.verificaResult(valorleft, valorright);
					RESULT = instance.criaNoResult();
					instance.trocaContexto(RESULT);
				:};

postfixResultExpAux ::= PONTO propertyCall:pc {: instance.trocaContexto(pc); :} postfixExpAux:rec 
				{:
					RESULT = instance.criaNoNavegacao(pc, rec);
				:} 
					| ACESSOCOLECOES:ac {: instance.verificaSeContextoEhColecao(acleft, acright); :}
				    				propertyCallCollection:pc {: instance.trocaContexto(pc); :} postfixExpAux:rec
				{:
				    RESULT = instance.criaNoNavegacao(pc, rec);
				:} | ;

primaryExpression ::= ifExpression:no
				{:
					instance.trocaContexto(no);
					RESULT = no;
				:}
					| literal:no
 				{:
  					instance.trocaContexto(no);
  					RESULT = no;
 	    	  	:}
					| propertyCall:no
 				{:
 					instance.trocaContexto(no);
 					RESULT = no;
 				:}
					| PARENTESQ expression:no PARENTDIR
 				{:
 					instance.trocaContexto(no);
 					RESULT = instance.criaNo(no.getTipo(), "(" + no.getValor() + ")");
 				:};

literal ::= number:no {: RESULT = no; :}
			| BOOL:valor {: RESULT = instance.criaNo(TipoPrimitivoEnum.BOOLEAN, valor); :}
			| STRING:valor {: RESULT = instance.criaNoDeString(valor); :};

propertyCallCollection ::= ID:nomeOp {: instance.iniciaOperacao(nomeOp); :} timeExpression propertyCallParameters:params
				{:
					instance.finalizaColetaParametros(); // volta contexto dos parametros
					instance.verificaNavegacaoOpColecao(nomeOpleft, nomeOpright, nomeOp);
					instance.verificaParamMetodo(nomeOpleft, nomeOpright, nomeOp);
					RESULT = instance.criaNoDeMetodo(true, nomeOpleft, nomeOpright, nomeOp, params);
				:} 
			| ID:nomeOp {: instance.iniciaOperacao(nomeOp); :} propertyCallParameters:params
				{:
					instance.finalizaColetaParametros(); // volta contexto dos parametros
					instance.verificaNavegacaoOpColecao(nomeOpleft, nomeOpright, nomeOp);
					instance.verificaParamMetodo(nomeOpleft, nomeOpright, nomeOp);
					RESULT = instance.criaNoDeMetodo(false, nomeOpleft, nomeOpright, nomeOp, params);
				:};

propertyCall ::= pathName:nomeOp timeExpression {: instance.iniciaOperacao(nomeOp); :} propertyCallParameters:params
				{:
				    instance.finalizaColetaParametros(); // volta contexto dos parametros
					instance.verificaNavegacaoMetodo(nomeOpleft, nomeOpright, nomeOp);
					instance.verificaParamMetodo(nomeOpleft, nomeOpright, nomeOp);
					instance.verificaOclIsNew(nomeOpleft, nomeOpright, nomeOp);
					RESULT = instance.criaNoDeMetodo(true, nomeOpleft, nomeOpright, nomeOp, params);
				:}
			 | pathName:nomeAttr timeExpression
				{:
					instance.verificaNavegacaoAttr(nomeAttrleft, nomeAttrright, nomeAttr);
					RESULT = instance.criaNoDeAtributo(true, nomeAttrleft, nomeAttrright, nomeAttr);
				:}
			 | pathName:nomeOp {: instance.iniciaOperacao(nomeOp); :} propertyCallParameters:params
				{:
					instance.finalizaColetaParametros(); // volta contexto dos parametros
					instance.verificaNavegacaoMetodo(nomeOpleft, nomeOpright, nomeOp);
					instance.verificaParamMetodo(nomeOpleft, nomeOpright, nomeOp);
					instance.verificaOclIsNew(nomeOpleft, nomeOpright, nomeOp);
					RESULT = instance.criaNoDeMetodo(false, nomeOpleft, nomeOpright, nomeOp, params);
				:}
			 | pathName:nomeAttr 
				{:
					instance.verificaNavegacaoAttr(nomeAttrleft, nomeAttrright, nomeAttr);
					RESULT = instance.criaNoDeAtributo(false, nomeAttrleft, nomeAttrright, nomeAttr);
				:};			
				
propertyCallParameters ::= PARENTESQ actualParameterList:no PARENTDIR
				{:
					RESULT = instance.criaNoParameterList(no);
				:}
			 | PARENTESQ PARENTDIR
			 	{:
			 		RESULT = instance.criaNoParameterList();
			 	:};		

actualParameterList ::= expression:no {: instance.addParamNaOperacao(no); :} actualParameterListAux:aux
				{:
					RESULT = instance.criaNoParameter(no, aux);
				:};

actualParameterListAux ::= VIRGULA expression:no {: instance.addParamNaOperacao(no); :} actualParameterListAux:aux
				{:
					RESULT = instance.criaNoParameter(no, aux);
				:} |;
				
timeExpression ::= APRE:valor {: instance.verificaAPre(valorleft, valorright); :};

number ::= INTEGER:valor {: RESULT = instance.criaNo(TipoPrimitivoEnum.INTEGER, valor); :}
	   	  | REAL:valor {: RESULT = instance.criaNo(TipoPrimitivoEnum.REAL, valor); :};

constraintAux ::= stereotype DOISPONTOS oclExpression:no
				 {:
					constraintAtual.addText(no.getValor());
					instance.addConstraintMetodoContexto(constraintAtual);
					constraintAtual = new Constraint();	
				 :} constraintRecursao
				 | stereotype ID:nomeConst DOISPONTOS oclExpression:no
				 {:
					constraintAtual.addText(no.getValor());
					instance.addConstraintMetodoContexto(constraintAtual);
					constraintAtual = new Constraint();	
				 :} constraintRecursao 
				 {:
				 	instance.verificaSeJaExisteCondicao(nomeConstleft, nomeConstright, nomeConst);
				 :};

constraint ::= contextDeclaration 
				 {:
					constraintAtual = new Constraint();	
				 :} constraintAux;

stereotype ::= PRE
				 {:
					instance.setPreCondicao(); 
					constraintAtual.setPreCondition(); 
				 :}
              | POST
              	 {:
              		instance.setPosCondicao(); 
              		constraintAtual.setPostCondition();
              	 :};

contextDeclaration ::= CONTEXT {: instance.iniciaContexto(); :} contextDefinition operationContext;

contextDefinition ::= contextDefinition ID:nome	{: instance.defineClasseOuPacote(nome);	:} DOISPONTOSDUPLO
            	   | ID:nome {: instance.defineClasseOuPacote(nome); :} DOISPONTOSDUPLO;

operationContext ::= operationName:nomeOp
				 {:
					instance.verificaClasseContexto(nomeOpleft, nomeOpright);
					instance.defineClasseDoContexto();
					instance.verificaOperacaoContexto(nomeOpleft, nomeOpright, nomeOp);
					instance.defineMetodoDoContexto(nomeOp);
				 :}
					PARENTESQ formalParameterList:fplist PARENTDIR DOISPONTOS returnType:ret
				 {:
				 	instance.verificaQuantidadeDeParametrosDoContexto(fplistleft, fplistright);
					instance.verificaRetornoContexto(retleft, retright, ret);
				 :};

returnType ::= typeSpecifier:tipo {: RESULT = tipo; :};

operationName ::= ID:nome {: RESULT = nome; :};

formalParameterList ::= ID:nome DOISPONTOS typeSpecifier:tipo
				 {:
				 	instance.verificaProximoParametroContexto(tipoleft, tiporight, tipo);
				 	instance.defineNovoParametroNoContexto(nome, tipo);
				 :} formalParameterListAux |;

formalParameterListAux ::= VIRGULA ID:nome DOISPONTOS typeSpecifier:tipo
				 {:
				 	instance.verificaProximoParametroContexto(tipoleft, tiporight, tipo);
				 	instance.defineNovoParametroNoContexto(nome, tipo);
				 :} formalParameterListAux |;

typeSpecifier ::= simpleTypeSpecifier:tipo {: RESULT = tipo; :}
				| collectionType:tipo {: RESULT = tipo; :};

collectionType ::= COLECAO:nomeColecao PARENTESQ simpleTypeSpecifier:tipo PARENTDIR 
				 {:
				 	RESULT = instance.defineTipoColecao(nomeColecao, tipo);
			     :};

simpleTypeSpecifier ::= pathName:val {: RESULT = val; :};

pathName ::= ID:nome {: RESULT = nome; :}
            | ID:nome DOISPONTOSDUPLO pathName:recursao {: RESULT = nome; :};

relationalOperator ::= IGUAL {: RESULT = ConstantesAnaliseSemantica.OP_EQUAL; :}
					 | MAIOR {: RESULT = ConstantesAnaliseSemantica.OP_B; :}
					 | MENOR {: RESULT = ConstantesAnaliseSemantica.OP_L; :} 
					 | MAIORIGUAL {: RESULT = ConstantesAnaliseSemantica.OP_BT; :}
					 | MENORIGUAL {: RESULT = ConstantesAnaliseSemantica.OP_LT; :}
					 | DIFERENTE {: RESULT = ConstantesAnaliseSemantica.OP_DIFF; :};

addOperator ::= MAIS {: RESULT = ConstantesAnaliseSemantica.OP_PLUS; :}
			  | MENOS {: RESULT = ConstantesAnaliseSemantica.OP_UNARY_MENOS; :};

multiplyOperator ::= VEZES {: RESULT = ConstantesAnaliseSemantica.OP_TIMES; :}
				   | DIVISAO {: RESULT = ConstantesAnaliseSemantica.OP_DIV; :};

unaryOperator ::= MENOS {: RESULT = ConstantesAnaliseSemantica.OP_UNARY_MENOS; :}
                | NOT {: RESULT = ConstantesAnaliseSemantica.OP_UNARY_NOT; :};

logicalOperator ::= AND {: RESULT = ConstantesAnaliseSemantica.OP_LOGICAL_AND; :}
				  | OR {: RESULT = ConstantesAnaliseSemantica.OP_LOGICAL_OR; :}
				  | XOR {: RESULT = ConstantesAnaliseSemantica.OP_LOGICAL_XOR; :}
				  | IMPLIES {: RESULT = ConstantesAnaliseSemantica.OP_LOGICAL_IMPLIES; :};
